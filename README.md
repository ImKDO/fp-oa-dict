# Лабораторная работа №2: Структуры данных

**Выполнил:** Кравченко Дмитрий Олегович  
**Группа:** P3319

---

## 1. Цели и требования

### 1.1 Цель работы
Освоить проектирование пользовательских типов данных в OCaml, обеспечить полиморфизм структур, реализовать рекурсивные алгоритмы и подготовить исчерпывающий набор модульных и property-based тестов.

### 1.2 Выбранная структура данных
**Персистентный словарь на основе ассоциативного списка**.  
Ключи представлены типом `int`, значения полиморфны (`'v`). Все операции иммутабельны: функции возвращают новую структуру без изменения исходной.

### 1.3 Функциональные требования

| Категория                   | Операции                                                                                         |
|----------------------------|----------------------------------------------------------------------------------------------------|
| Основные                   | `make_empty`, `is_empty`, `insert`, `remove`, `find`, `mem`, `size`                                |
| Функции высшего порядка    | `map`, `filter`, `fold_left`, `fold_right`                                                         |
| Моноидальные операции      | `concat` (ассоциативность, левая/правая единица — `make_empty ()`)                                 |
| Конвертеры и сравнение     | `to_list`, `of_list`, `equal`                                                                      |

### 1.4 Нефункциональные требования

1. **Иммутабельность** — каждое изменение создаёт новую структуру.
2. **Полиморфизм** — значения словаря не зависят от конкретного типа.
3. **Простота реализации** — чистый функциональный стиль, рекурсивные вспомогательные функции.
4. **Тестируемость** — покрытие модульными и property-based тестами.

---

## 2. Реализация

### 2.1 Типы данных

```Lab2/lib/oa_dict.ml#L24-30
module OA_Dict = struct
  type key = int
  type 'v t = { size : int; entries : (key * 'v) list }

  let make_empty () = { size = 0; entries = [] }
  let is_empty d = d.size = 0
```

Использование списка обеспечивает простую персистентность и понятную семантику вставки/удаления. Размер хранится отдельно, что упрощает проверку инвариантов и ускоряет операции `size` и `is_empty`.

### 2.2 Вставка и обновление

```Lab2/lib/oa_dict.ml#L31-39
  let rec replace_or_insert k v acc = function
    | [] -> ((k, v) :: acc |> List.rev, false)
    | (k', _) :: rest when k' = k -> (List.rev acc @ ((k, v) :: rest), true)
    | pair :: rest -> replace_or_insert k v (pair :: acc) rest

  let insert k v d =
    let new_entries, replaced = replace_or_insert k v [] d.entries in
    let new_size = if replaced then d.size else d.size + 1 in
    { size = new_size; entries = new_entries }
```

- Рекурсивный обход ищет существующий ключ.
- Возвращает флаг, был ли элемент заменён (для корректного обновления `size`).
- Используется в `insert`, где структура пересоздаётся с учётом результатов обхода.

### 2.3 Удаление

```Lab2/lib/oa_dict.ml#L41-48
  let rec remove_helper k acc removed = function
    | [] -> (List.rev acc, removed)
    | (k', _) :: rest when k' = k -> (List.rev_append acc rest, true)
    | pair :: rest -> remove_helper k (pair :: acc) removed rest

  let remove k d =
    let entries, removed = remove_helper k [] false d.entries in
    if removed then { size = d.size - 1; entries } else d
```

Удаление выполняется за один проход, сохраняя порядок остальных элементов. Размер декрементируется только при фактическом удалении.

### 2.4 Функции высшего порядка

- `map` — применяет функцию к значениям, сохраняя ключи и порядок.
- `filter` — оставляет пары, удовлетворяющие предикату, размер пересчитывается по длине результирующего списка.
- `fold_left` / `fold_right` — реализованы через стандартные `List.fold_left`/`List.fold_right`.

### 2.5 Моноидальные свойства

`concat d1 d2` последовательно вставляет элементы второго словаря в первый (правый аргумент имеет приоритет по ключам). Это обеспечивает:

- ассоциативность;
- левую/правую идентичность относительно `make_empty ()`.

### 2.6 Конвертеры и сравнение

- `to_list`/`of_list` — взаимно обратные функции (за вычетом перезаписи дубликатов при восстановлении).
- `equal eq d1 d2` — сравнение по ключам и значениями с пользовательской функцией равенства, за время `O(n)`.

---

## 3. Тестирование

### 3.1 Средства

- **Alcotest** — юнит-тесты.
- **QCheck + qcheck-alcotest** — property-based тесты.

### 3.2 Набор тестов

| Категория                     | Кол-во | Краткое описание                                                                       |
|------------------------------|--------|------------------------------------------------------------------------------------------|
| Юнит-тесты                   | 19     | Проверка базовых операций, функций высшего порядка, конвертеров, моноидальных свойств.   |
| Property-based тесты         | 10     | Инварианты вставки/удаления, свойства моноида, корректность `map`/`filter`, рефлексивность `equal`. |

### 3.3 Запуск

```/dev/null/commands.txt#L1-1
opam exec -- dune test
```

Команда выполняет Alcotest-сценарии и автоматически интегрированные QCheck-тесты. На текущем состоянии проекта все 29 тестов проходят успешно.

---

## 4. Выводы

1. **Иммутабельная структура** на основе ассоциативного списка обеспечивает простоту и предсказуемость поведения.
2. **Полное покрытие тестами** (unit + property-based) фиксирует основные инварианты и функциональные требования.
